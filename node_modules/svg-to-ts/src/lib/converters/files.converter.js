"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToFiles = void 0;
const typescript_compiler_1 = require("../compiler/typescript-compiler");
const code_snippet_generators_1 = require("../generators/code-snippet-generators");
const complete_icon_set_helper_1 = require("../helpers/complete-icon-set.helper");
const file_helpers_1 = require("../helpers/file-helpers");
const logger_1 = require("../helpers/logger");
const monitor_1 = require("../helpers/monitor");
const regex_helpers_1 = require("../helpers/regex-helpers");
const files_conversion_options_1 = require("../options/conversion-options/files-conversion-options");
const file_type_model_1 = require("../shared/file-type.model");
const shared_converter_1 = require("./shared.converter");
const convertToFiles = (conversionOptions) => __awaiter(void 0, void 0, void 0, function* () {
    const { tsx } = conversionOptions;
    if (tsx) {
        yield generateTSXFiles(conversionOptions);
    }
    else {
        yield generateTSFiles(conversionOptions);
    }
});
exports.convertToFiles = convertToFiles;
function generateTSXFiles(conversionOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const { outputDirectory, iconsFolderName, exportCompleteIconSet, completeIconSetName, barrelFileName, interfaceName, generateType, modelFileName, } = conversionOptions;
        const svgDefinitions = yield (0, monitor_1.callAndMonitorAsync)(shared_converter_1.filesProcessor.bind({}, conversionOptions), 'Processing SVG files');
        const generatedFileNames = yield (0, monitor_1.callAndMonitorAsync)(generateTSXFileConstants.bind({}, svgDefinitions, outputDirectory, iconsFolderName), 'Generate TSX constants');
        if (exportCompleteIconSet) {
            yield (0, monitor_1.callAndMonitorAsync)(generateCompleteIconSet.bind({}, svgDefinitions, outputDirectory, iconsFolderName, completeIconSetName, interfaceName, generateType, modelFileName), 'Export complete icon set');
            generatedFileNames.push(completeIconSetName);
        }
        const indexFileContent = generatedFileNames
            .map((generatedFileName) => (0, code_snippet_generators_1.generateExportStatement)(generatedFileName, iconsFolderName))
            .join('');
        yield (0, monitor_1.callAndMonitorAsync)(file_helpers_1.writeFile.bind({}, outputDirectory, barrelFileName, indexFileContent), 'Generate barrel file');
        logger_1.Logger.generationSuccess(outputDirectory);
    });
}
function generateTSFiles(conversionOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const { outputDirectory, modelFileName, additionalModelOutputPath, iconsFolderName, interfaceName, compileSources, exportCompleteIconSet, completeIconSetName, compilationOutput, barrelFileName, generateType, } = conversionOptions;
        yield (0, monitor_1.callAndMonitorAsync)(file_helpers_1.deleteFolder.bind({}, `${outputDirectory}/${iconsFolderName}`), 'Deleting the output folder');
        const svgDefinitions = yield (0, monitor_1.callAndMonitorAsync)(shared_converter_1.filesProcessor.bind({}, conversionOptions), 'Processing SVG files');
        const generatedFileNames = yield (0, monitor_1.callAndMonitorAsync)(generateSVGConstants.bind({}, svgDefinitions, outputDirectory, iconsFolderName), 'Generate SVG constants');
        if (exportCompleteIconSet) {
            yield (0, monitor_1.callAndMonitorAsync)(generateCompleteIconSet.bind({}, svgDefinitions, outputDirectory, iconsFolderName, completeIconSetName, interfaceName, modelFileName, generateType), 'Export complete icon set');
            generatedFileNames.push(completeIconSetName);
        }
        let indexFileContent = (0, monitor_1.callAndMonitor)(code_snippet_generators_1.generateTypeHelperWithImport.bind({}, interfaceName, iconsFolderName, modelFileName), 'Generate Type Helper');
        indexFileContent += generatedFileNames
            .map((generatedFileName) => (0, code_snippet_generators_1.generateExportStatement)(generatedFileName, iconsFolderName))
            .join('');
        indexFileContent += (0, code_snippet_generators_1.generateExportStatement)(modelFileName, iconsFolderName);
        yield (0, monitor_1.callAndMonitorAsync)(file_helpers_1.writeFile.bind({}, outputDirectory, barrelFileName, indexFileContent), 'Generate barrel file');
        if (modelFileName) {
            const modelFile = yield (0, monitor_1.callAndMonitorAsync)(generateModelFile.bind({}, conversionOptions, svgDefinitions), 'Generate model file');
            if (additionalModelOutputPath) {
                yield (0, monitor_1.callAndMonitorAsync)(file_helpers_1.writeFile.bind({}, `${additionalModelOutputPath}`, modelFileName, modelFile), 'Write model file to additional output path');
            }
        }
        if (compileSources) {
            yield (0, monitor_1.callAndMonitorAsync)(compileTypeScriptToJS.bind({}, outputDirectory, iconsFolderName, barrelFileName, compilationOutput), 'Compile TypeScript to JavaScript');
        }
        logger_1.Logger.generationSuccess(outputDirectory);
    });
}
const generateSVGConstants = (svgDefinitions, outputDirectory, iconsFolderName) => __awaiter(void 0, void 0, void 0, function* () {
    const generatedFileNames = [];
    yield Promise.all(svgDefinitions.map((svgDefinition) => __awaiter(void 0, void 0, void 0, function* () {
        const svgConstant = (0, code_snippet_generators_1.generateSvgConstant)(svgDefinition.variableName, svgDefinition.typeName, svgDefinition.data);
        const generatedFileName = `${svgDefinition.prefix}-${svgDefinition.filenameWithoutEnding}.icon`;
        generatedFileNames.push(generatedFileName);
        yield (0, file_helpers_1.writeFile)(`${outputDirectory}/${iconsFolderName}`, generatedFileName, svgConstant);
        logger_1.Logger.verboseInfo(`write file svg: ${outputDirectory}/${iconsFolderName}/${generatedFileName}.ts`);
    })));
    return generatedFileNames;
});
const generateTSXFileConstants = (svgDefinitions, outputDirectory, iconsFolderName) => __awaiter(void 0, void 0, void 0, function* () {
    const generatedFileNames = [];
    yield Promise.all(svgDefinitions.map((svgDefinition) => __awaiter(void 0, void 0, void 0, function* () {
        const tsxConstant = (0, code_snippet_generators_1.generateTSXConstant)(svgDefinition.variableName, svgDefinition.data);
        const generatedFileName = `${svgDefinition.prefix}-${svgDefinition.filenameWithoutEnding}.icon`;
        generatedFileNames.push(generatedFileName);
        yield (0, file_helpers_1.writeFile)(`${outputDirectory}/${iconsFolderName}`, generatedFileName, tsxConstant, file_type_model_1.FILE_TYPE.TSX);
        logger_1.Logger.verboseInfo(`write file svg: ${outputDirectory}/${iconsFolderName}/${generatedFileName}.tsx`);
    })));
    return generatedFileNames;
});
const generateCompleteIconSet = (svgDefinitions, outputDirectory, iconsFolderName, completeIconSetName, interfaceName, modelFileName, generateType) => __awaiter(void 0, void 0, void 0, function* () {
    const completeIconSetContent = (0, complete_icon_set_helper_1.generateCompleteIconSetContent)(svgDefinitions, completeIconSetName, interfaceName, modelFileName, generateType);
    yield (0, file_helpers_1.writeFile)(`${outputDirectory}/${iconsFolderName}`, completeIconSetName, completeIconSetContent);
});
const generateModelFile = (conversionOptions, svgDefinitions) => __awaiter(void 0, void 0, void 0, function* () {
    const { outputDirectory, modelFileName, additionalModelOutputPath, iconsFolderName } = conversionOptions;
    const typeDefinition = (0, code_snippet_generators_1.generateTypeDefinition)(conversionOptions, svgDefinitions);
    const enumDefinition = (0, code_snippet_generators_1.generateEnumDefinition)(conversionOptions, svgDefinitions);
    const interfaceDefinition = (0, code_snippet_generators_1.generateInterfaceDefinition)(conversionOptions);
    const modelFile = `${typeDefinition}${interfaceDefinition}${enumDefinition}`;
    yield (0, file_helpers_1.writeFile)(`${outputDirectory}/${iconsFolderName}`, modelFileName, modelFile);
    logger_1.Logger.verboseInfo(`model-file successfully generated under ${outputDirectory}/${iconsFolderName}/${modelFileName}.ts`);
    if (additionalModelOutputPath) {
        yield (0, file_helpers_1.writeFile)(`${additionalModelOutputPath}`, modelFileName, modelFile);
        logger_1.Logger.verboseInfo(`additional model-file successfully generated under ${additionalModelOutputPath}/${modelFileName}.ts`);
    }
    return modelFile;
});
const compileTypeScriptToJS = (outputDirectory, iconsFolderName, barrelFileName, compilationOutput) => __awaiter(void 0, void 0, void 0, function* () {
    const generatedTypeScriptFilePaths = yield (0, regex_helpers_1.getFilePathsFromRegex)([
        `${outputDirectory}/${iconsFolderName}/*.ts`,
        `${outputDirectory}/${barrelFileName}.ts`,
    ]);
    switch (compilationOutput) {
        case files_conversion_options_1.SVG_TO_TS_COMPILATION_OUTPUT.ESM:
            (0, typescript_compiler_1.compileToEsNext)(generatedTypeScriptFilePaths, outputDirectory);
            (0, file_helpers_1.deleteFiles)(generatedTypeScriptFilePaths);
            break;
        case files_conversion_options_1.SVG_TO_TS_COMPILATION_OUTPUT.UMD:
            (0, typescript_compiler_1.compileToUMD)(generatedTypeScriptFilePaths, outputDirectory);
            (0, file_helpers_1.deleteFiles)(generatedTypeScriptFilePaths);
            break;
        case files_conversion_options_1.SVG_TO_TS_COMPILATION_OUTPUT.ESM_AND_UMD:
            (0, typescript_compiler_1.compileToEsNext)(generatedTypeScriptFilePaths, `${outputDirectory}/esm`);
            (0, typescript_compiler_1.compileToUMD)(generatedTypeScriptFilePaths, `${outputDirectory}/umd`);
            (0, file_helpers_1.deleteFiles)(generatedTypeScriptFilePaths);
            yield (0, file_helpers_1.deleteFolder)(`${outputDirectory}/build`);
            break;
        default:
            logger_1.Logger.error(`Please provide a valid Compilation output. You provided ${compilationOutput} but 
            valid values are (ESM, UMD, ESM_AND_UMD).`);
            break;
    }
});
//# sourceMappingURL=files.converter.js.map